beta(r[i][j]) = 1 / (1 + alpha * (r[i][j]) ^ ( 1 / h ) )


# Параметры слоя:

* field_width = 6 - количество нейронов в блоке по ширине
* field_height = 6 - количество нейронов в блоке по высоте
* layer_width = 5 - количество блоков в слое по ширине
* layer_height = 5 - количество блоков в слое по высоте

# Константы:

* alpha = 20.0
* gamma = 0.5
* g_dec = 0.001
* g_inc = 0.1
* g_0 = 1.0
* initial_strong_g = 10.0
* h = 2
* refract_interval = 3
* threshold = 0.9

# Алгоритм

## Обозначения

### Параметры сети

* accumulated_weights_1_to_2, accumulated_weights_2_to_1 - накопительные коэффициэнты синапсов, изменяются при каждом такте
* distance_weights_1_to_2, distance_weights_2_to_1 - коэффициэнты расстояний между нейронами, расчитываются при инициализации и не изменяются
* neurons_1, neurons_2 - булевы состояния возбуждённости нейронов сети
* refract_intervals_1, refract_intervals_2 - количество тактов невосприимчивости нейронов сети

### Функции

* exp - экспонента
* pow - возведение в степень

## Инициализация

1. Настройка accumulated_weights_1_to_2 и accumulated_weights_2_to_1: если нейроны в блоках друг другу соответствуют, вес равен initial_strong_g, в противном случае 0

2. Настройка distance_weights_1_to_2 и distance_weights_2_to_1:

    2.1. Вычисляется геометрическое расстояние между нейронами distance (при переходе от 2 слоя к 1 со смещением к следующему блоку)

    2.2. Результат равен: 1 / (1 + alpha * pow(distance, 1 / h))

3. Всем neurons_1 и neurons_2 присвоить 0

4. Всем refract_intervals_1 и refract_intervals_2 присвоить 0

## Такт работы

1. Запись входного сигнала в первый блок первого слоя нейронов

2. Для каждого neurons[index] и refract_intervals[index] каждого слоя выполнить пересчёт:

    2.1. Если значение refract_intervals[index] данного нейрона больше 0, уменьшить его на 1, а в neurons[index] записать 0

    2.2. Для каждого возбуждённого нейрона из противоположного слоя вычислить весовой коэффициент по формуле:

        2.2.1. При расчёте 1 слоя g = 0, при расчёте 2 слоя g = g_0

        2.2.1. Если accumulated_weight между нейронами < g, значение = 0

        2.2.2. В противном случае, значение = 1 - exp(-gamma * (accumulated_weight - g))

    2.3. Вычислить sum = сумме значений шага 2.2

    2.4. Если sum > threshold, refract_intervals[index] = refract_interval, neurons[index] = 1, в противном случае refract_intervals[index] = 0, neurons[index] = 0

3. Для каждого accumulated_weights каждого слоя выпонить пересчёт:

    3.1. Если нейрон подающего слоя в данный момент невозбуждён, не менять значение accumulated_weights, в противном случае:

    3.2. Если нейрон принимающего слоя в данный момент возбуждён, увеличить значение accumulated_weights на g_inc, в противном случае:

    3.3. Если refract_intervals принимающего слоя был > 0 до текущего такта, уменьшить значение accumulated_weights на g_dec, в противном случае:

    3.4. Не менять значение accumulated_weights
